<nav class="navbar navbar-expand-lg  navbar-dark bg-dark">
  <div class="container">
    <a href="https://github.com/dhilt/ngx-ui-scroll" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#343a40; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <a class="navbar-brand mr-auto ml-2 ml-lg-0" href="https://github.com/dhilt/ngx-ui-scroll">ngx-ui-scroll</a>
    <br>
    <span class="copyrights">
      2018 &copy; <a href="https://github.com/dhilt">dhilt</a>, <a href="http://www.hill30.com/">Hill30 Inc</a>
    </span>
  </div>
</nav>

<div class="container mb-5">

  <h1>Angular UI Scroll Demo</h1>

  <div class="demo">

    <h3 id="unlimited-bidirectional-scrolling">
      Unlimited bidirectional scrolling
      <a href="#unlimited-bidirectional-scrolling">#</a>
    </h3>

    <div class="work">
      <div style="float: left">
        <div class="viewport" id="basic">
          <div *uiScroll="let item of datasourceBasic">
            <b>{{item.text}}</b>
          </div>
        </div>
      </div>
      <div class="log elements">
        DOM elements
        <pre>{{elements('basic')}}</pre>
      </div>
      <div class="log datasource">
        Datasource.get log
        <pre>{{logBasic}}</pre>
      </div>
      <div class="clearfix mb-3"></div>
    </div>

    <div class="sources">
      <tabset>
        <tab heading="Component">
<pre class="prettyprint" ngNonBindable>
datasource: Datasource = &#123;
  get: (index, count, success) => &#123;
    const data = [];
    for (let i = index; i <= index + count - 1; i++) &#123;
      data.push(&#123; id: i, text: 'item #' + i &#125;);
    &#125;
    success(data);
  &#125;
&#125;
</pre>
        </tab>
        <tab heading="Template">
<pre class="prettyprint lang-html" ngNonBindable>
&lt;div class="viewport"&gt;
  &lt;div *uiScroll="let item of datasource"&gt;
    &lt;b&gt;{{item.text}}&lt;/b&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
        </tab>
        <tab heading="CSS">
<pre class="prettyprint" ngNonBindable>
body &#123;
  line-height: 25px;
&#125;
.viewport &#123;
  width: 175px;
  height: 175px;
  overflow-y: auto;
  overflow-anchor: none;
&#125;
</pre>
        </tab>
      </tabset>
    </div>

    <div class="description">
      <p>
        As it follows from the documentation, a special <em>Datasource</em> object needs to be passed to the
        <em>*uiScroll</em> directive. The basic ngx-ui-scroll example includes primitive callback-based
        <em>Datasource.get</em> method implementation with no additional settings. The use on the <em>*uiScroll</em>
        directive at the template layer is very similar to the use of <em>*ngFor</em> directive in the simplest case. In
        addition to <em>Datasource</em>, a special viewport container is specified at the template. It defines the
        scrollable area via <em>height</em> and <em>overflow</em> css properties.
      </p>
      <p>
        <em>Datasource.get</em> log shows us that there are 4 requests of 5 items on the initial load (before
        scrolling). So we have 20 DOM elements (4 * 5) initially. The number of DOM elements is not constant during
        user scrolling, but it fluctuates around the initial value. Why do we get 5 items per each
        <em>datasource.get</em> call? It is so because of default. We may change it via settings object and
        <em>bufferSize</em> property.
      </p>
    </div>
  </div>

  <div class="demo">
    <h3 id="bufferSize-setting">
      bufferSize setting
      <a href="#bufferSize-setting">#</a>
    </h3>

    <div class="work">
      <div style="float: left">
        <div class="viewport" id="buffer">
          <div *uiScroll="let item of datasourceBuffer">
            <b>{{item.text}}</b>
          </div>
        </div>
      </div>
      <div class="log elements">
        DOM elements
        <pre>{{elements('buffer')}}</pre>
      </div>
      <div class="log datasource">
        Datasource.get log
        <pre>{{logBuffer}}</pre>
      </div>
      <div class="clearfix mb-3"></div>
    </div>

    <div class="sources">
      <tabset>
        <tab heading="Component">
<pre class="prettyprint" ngNonBindable>
datasource: Datasource = &#123;
  get: (index, count, success) => &#123;
    const data = [];
    for (let i = index; i <= index + count - 1; i++) &#123;
      data.push(&#123; id: i, text: 'item #' + i &#125;);
    &#125;
    success(data);
  &#125;,
  settings: &#123;
    bufferSize: 15
  &#125;
&#125;
</pre>
        </tab>
        <tab heading="Template">
<pre class="prettyprint lang-html" ngNonBindable>
&lt;div class="viewport"&gt;
  &lt;div *uiScroll="let item of datasource"&gt;
    &lt;b&gt;{{item.text}}&lt;/b&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
        </tab>
        <tab heading="CSS">
<pre class="prettyprint" ngNonBindable>
 body &#123;
  line-height: 25px;
&#125;
.viewport &#123;
  width: 175px;
  height: 175px;
  overflow-y: auto;
  overflow-anchor: none;
&#125;
</pre>
        </tab>
      </tabset>
    </div>

    <div>
      <p>
        In addition to <em>get</em> method, <em>settings</em> object can be declared on the <em>Datasource</em>. Here
        we set <em>bufferSize</em> property which defines number of items requested from the datasource in a single
        request. Now the initial load consist of 2 requests (from 1 to 15 and from -14 to 0). The bigger the
        <em>bufferSize</em> is, the less requests are needed to fill out the viewport. The default value of
        <em>bufferSize</em> property is 5. The minimum value is 1. Another setting which has an impact on the
        viewport's filling procedure is <em>padding</em>.
      </p>
    </div>
  </div>

  <div class="demo">
    <h3 id="padding-mode">
      padding setting
      <a href="#padding-mode">#</a>
    </h3>

    <div class="work">
      <div style="float: left">
        <div class="viewport" id="padding">
          <div *uiScroll="let item of datasourcePadding">
            <b>{{item.text}}</b>
          </div>
        </div>
      </div>
      <div class="log elements">
        DOM elements
        <pre>{{elements('padding')}}</pre>
      </div>
      <div class="log datasource">
        Datasource.get log
        <pre>{{logPadding}}</pre>
      </div>
      <div class="clearfix mb-3"></div>
    </div>

    <div class="sources">
      <tabset>
        <tab heading="Component">
<pre class="prettyprint" ngNonBindable>
datasource: Datasource = &#123;
  get: (index, count, success) => &#123;
    const data = [];
    for (let i = index; i <= index + count - 1; i++) &#123;
      data.push(&#123; id: i, text: 'item #' + i &#125;);
    &#125;
    success(data);
  &#125;,
  settings: &#123;
    bufferSize: 7,
    padding: 1.4
  &#125;
&#125;
</pre>
        </tab>
        <tab heading="Template">
<pre class="prettyprint lang-html" ngNonBindable>
&lt;div class="viewport"&gt;
  &lt;div *uiScroll="let item of datasource"&gt;
    &lt;b&gt;{{item.text}}&lt;/b&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
        </tab>
        <tab heading="CSS">
<pre class="prettyprint" ngNonBindable>
 body &#123;
  line-height: 25px;
&#125;
.viewport &#123;
  width: 175px;
  height: 175px;
  overflow-y: auto;
  overflow-anchor: none;
&#125;
</pre>
        </tab>
      </tabset>
    </div>

    <div class="description">
      <p>
        Here the <em>Datasource.get</em> is taken from previous samples, but the settings object is completed with
        <em>padding</em> property. <em>Padding</em> is an extra space added to the visible part of the viewport for
        the purpose of determining when the items should be created/destroyed. The value is relative to the visible
        size of the viewport. <em>1.4</em> means that the <em>*uiScroll</em> directive would request new items until
        140% of the viewport size (out of the visible part of the viewport) is filled with rendered items. That's why
        we have 5 requests on the initial load in this case. There are 3 downward requests:
      </p>
      <ol>
        <li>175px + 1.4 * 175px = 420px (downward space which has to be filled, when viewport's height = 175px )</li>
        <li>ceil(420px / 25px) = 17 (items that are needed to feel 420px of the downward space, when item's height =
          25px )
        </li>
        <li>ceil(17 / 7) = 3 (datasource.get calls that are needed to request 17 items, when bufferSize = 7)</li>
      </ol>
      <p>
        And 2 upward requests:
      </p>
      <ol>
        <li>1.4 * 175px = 245px (upward space which have to be filled)</li>
        <li>ceil(245px / 25px) = 10 (items that are needed to feel 245px of the upward space)</li>
        <li>ceil(10 / 7) = 2 (datasource.get calls that are needed to request 10 items)</li>
      </ol>
      <p>
        The default value of <em>padding</em> property is 0.5. The minimum value is 0.1.
      </p>
    </div>
  </div>

  <div class="demo">
    <h3 id="infinite-mode">
      Infinite mode
      <a href="#infinite-mode">#</a>
    </h3>

    <div class="work">
      <div style="float: left">
        <div class="viewport" id="infinite">
          <div *uiScroll="let item of datasourceInfinite">
            <b>{{item.text}}</b>
          </div>
        </div>
      </div>
      <div class="log elements">
        DOM elements
        <pre>{{elements('infinite')}}</pre>
      </div>
      <div class="log datasource">
        Datasource.get log
        <pre>{{logInfinite}}</pre>
      </div>
      <div class="clearfix mb-3"></div>
    </div>

    <div class="sources">
      <tabset>
        <tab heading="Component">
<pre class="prettyprint" ngNonBindable>
datasource: Datasource = &#123;
  get: (index, count, success) => &#123;
    const data = [];
    for (let i = index; i <= index + count - 1; i++) &#123;
      data.push(&#123; id: i, text: 'item #' + i &#125;);
    &#125;
    success(data);
  &#125;,
  settings: &#123;
    infinite: true
  &#125;
&#125;
</pre>
        </tab>
        <tab heading="Template">
<pre class="prettyprint lang-html" ngNonBindable>
&lt;div class="viewport"&gt;
  &lt;div *uiScroll="let item of datasource"&gt;
    &lt;b&gt;{{item.text}}&lt;/b&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
        </tab>
        <tab heading="CSS">
<pre class="prettyprint" ngNonBindable>
 body &#123;
  line-height: 25px;
&#125;
.viewport &#123;
  width: 175px;
  height: 175px;
  overflow-y: auto;
  overflow-anchor: none;
&#125;
</pre>
        </tab>
      </tabset>
    </div>

    <div class="description">
      <p>
        The <em>*uiScroll</em> directive might work in the "infinite" mode, when items are never removed. This mode can
        be turned on via <em>infinite</em> property of the <em>settings</em> object. Setting <em>infinite</em> to true,
        we ask the scroller not to remove items that are getting out of the viewport. That's why the DOM elements
        counter value is being increased per each edge-scroll event.
      </p>
    </div>
  </div>

  <div class="demo">
    <h3 id="horizontal-mode">
      Horizontal mode
      <a href="#horizontal-mode">#</a>
    </h3>

    <div class="work">
      <div style="float: left">
        <div class="viewport-horizontal" id="horizontal">
          <div *uiScroll="let item of datasourceHorizontal">
            <div class="item-horizontal">{{item.text}}</div>
          </div>
        </div>
      </div>
      <div class="log elements horizontal">
        DOM elements
        <pre>{{elements('horizontal')}}</pre>
      </div>
      <div class="log datasource horizontal">
        Datasource.get log
        <pre>{{logHorizontal}}</pre>
      </div>
      <div class="clearfix mb-3"></div>
    </div>

    <div class="sources">
      <tabset>
        <tab heading="Component">
<pre class="prettyprint" ngNonBindable>
datasource: Datasource = &#123;
  get: (index, count, success) => &#123;
    const data = [];
    for (let i = index; i <= index + count - 1; i++) &#123;
      data.push(&#123; id: i, text: 'item #' + i &#125;);
    &#125;
    success(data);
  &#125;,
  settings: &#123;
    horizontal: true
  &#125;
&#125;
</pre>
        </tab>
        <tab heading="Template">
<pre class="prettyprint lang-html" ngNonBindable>
&lt;div class="viewport-horizontal"&gt;
  &lt;div *uiScroll="let item of datasource"&gt;
    &lt;div class="item-horizontal"&gt;{{item.text}}&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
        </tab>
        <tab heading="CSS">
<pre class="prettyprint" ngNonBindable>
.viewport-horizontal &#123;
  width: 175px;
  height: 100px;
  overflow-anchor: none;
  overflow-x: scroll;
  overflow-y: hidden;
  white-space: nowrap;
&#125;
.viewport-horizontal div &#123;
  display: inline-block;
&#125;
.item-horizontal &#123;
  border: 1px solid #aaa;
  height: 100px;
  padding: 0 5px;
  font-weight: bolder;
&#125;
</pre>
        </tab>
      </tabset>
    </div>

    <p>
      Horizontal scrolling could be enabled via <em>horizontal</em> setting. The styles also need to be fixed in
      accordance with horizontal scrolling. Currently we have some limitations at the template layer but
      <em>display: inline-block;</em> rule applied to all nested containers makes the horizontal mode work.
    </p>

  </div>
</div>
